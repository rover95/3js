<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 3D Demo</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@v0.149.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.149.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
      import * as THREE from 'three';
        // 场景、相机、渲染器
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 添加光源
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 10, 10).normalize();
        scene.add(light);

        // 网格地面
        const gridHelper = new THREE.GridHelper(100, 100);
        scene.add(gridHelper);



       // 创建起伏的网格平面
const planeSize = 100; // 平面大小
const planeSegments = 100; // 平面的分段数（控制起伏的精细度）
const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize, planeSegments, planeSegments);

// 为每个顶点设置随机高度和颜色
const positionAttribute = planeGeometry.attributes.position;
const colors = []; // 存储顶点颜色

for (let i = 0; i < positionAttribute.count; i++) {
    const x = positionAttribute.getX(i);
    const y = positionAttribute.getY(i);
    const z = positionAttribute.getZ(i);

    // 设置随机高度（起伏效果）
    const height = Math.random() * 2; // 随机高度范围
    positionAttribute.setZ(i, height);

    // 根据高度设置颜色
    const color = new THREE.Color();
    if (height < 0.5) {
        color.set(0x00ff00); // 低处为绿色
    } else if (height < 1) {
        color.set(0xffff00); // 中等高度为黄色
    } else {
        color.set(0xff0000); // 高处为红色
    }

    // 将颜色添加到数组
    colors.push(color.r, color.g, color.b);
}

// 将颜色数据赋值给几何体的 color 属性
planeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

// 更新几何体以应用修改
planeGeometry.attributes.position.needsUpdate = true;
planeGeometry.computeVertexNormals(); // 重新计算法线，确保光照效果正确

// 创建材质
const planeMaterial = new THREE.MeshPhongMaterial({
    vertexColors: true, // 启用顶点颜色
    side: THREE.DoubleSide,
    flatShading: true // 使用平面着色，增强起伏效果
});

// 创建网格
const plane = new THREE.Mesh(planeGeometry, planeMaterial);
plane.rotation.x = -Math.PI / 2; // 旋转平面使其水平
scene.add(plane);



        // 立方体（模拟人）
        const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
        const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.y = 1;
        scene.add(cube);

        // 相机初始位置
        const cameraDistance = 20; // 相机与立方体的距离
        let cameraAngleX = 0; // 相机绕 Y 轴旋转的角度
        let cameraAngleY = Math.PI / 4; // 相机绕 X 轴旋转的角度

        function updateCameraPosition() {
            camera.position.x = cube.position.x + cameraDistance * Math.sin(cameraAngleX) * Math.cos(cameraAngleY);
            camera.position.y = cube.position.y + cameraDistance * Math.sin(cameraAngleY);
            camera.position.z = cube.position.z + cameraDistance * Math.cos(cameraAngleX) * Math.cos(cameraAngleY);
            camera.lookAt(cube.position);
        }
        updateCameraPosition();

        // 键盘控制
        const moveSpeed = 0.1;
        const keys = { w: false, a: false, s: false, d: false };

        window.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'w': keys.w = true; break;
                case 'a': keys.a = true; break;
                case 's': keys.s = true; break;
                case 'd': keys.d = true; break;
            }
        });

        window.addEventListener('keyup', (event) => {
            switch (event.key) {
                case 'w': keys.w = false; break;
                case 'a': keys.a = false; break;
                case 's': keys.s = false; break;
                case 'd': keys.d = false; break;
            }
        });

        // 鼠标控制变量
        let isMouseDown = false;
        let previousMousePosition = {
            x: 0,
            y: 0
        };

        // 鼠标按下事件
        window.addEventListener('mousedown', (event) => {
            if (event.button === 0) { // 0 表示左键
                isMouseDown = true;
            }
        });

        // 鼠标松开事件
        window.addEventListener('mouseup', (event) => {
            if (event.button === 0) {
                isMouseDown = false;
            }
        });

        // 鼠标移动事件
        window.addEventListener('mousemove', (event) => {
          if (isMouseDown) {
              const deltaMove = {
                  x: event.clientX - previousMousePosition.x,
                  y: event.clientY - previousMousePosition.y
              };

              // 根据鼠标移动调整相机角度
              cameraAngleX -= deltaMove.x * 0.01; // 左右旋转
              cameraAngleY -= deltaMove.y * 0.01; // 上下旋转

              // 限制上下旋转角度，允许旋转到平面以下，但避免完全倒置
              cameraAngleY = Math.max(-Math.PI * 0.8, Math.min(Math.PI * 0.8, cameraAngleY));
              if(cameraAngleY<0)cameraAngleY = 0

              // 更新相机位置
              updateCameraPosition();
          }

          previousMousePosition = {
              x: event.clientX,
              y: event.clientY
          };
        });

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);

            // 根据相机朝向计算移动方向
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction); // 获取相机的朝向
            direction.y = 0; // 忽略 Y 轴，确保水平移动
            direction.normalize();

            // 移动立方体
            if (keys.w) {
                cube.position.addScaledVector(direction, moveSpeed); // 向前移动
            }
            if (keys.s) {
                cube.position.addScaledVector(direction, -moveSpeed); // 向后移动
            }
            if (keys.a) {
                const leftDirection = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), direction); // 计算左方向
                cube.position.addScaledVector(leftDirection, moveSpeed); // 向左移动
            }
            if (keys.d) {
                const rightDirection = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0)); // 计算右方向
                cube.position.addScaledVector(rightDirection, moveSpeed); // 向右移动
            }

            // 更新相机位置
            updateCameraPosition();

            renderer.render(scene, camera);
        }

        animate();

        // 窗口大小调整
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>